import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from './use-auth';
import { useToast } from './use-toast';
import { queryClient } from '@/lib/queryClient';

// Fun√ß√£o global de debug para maior visibilidade nos logs
const debugLogger = (context: string, message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${context}] ${message}`, data || '');
};

type WebSocketMessage = {
  type: 'connection' | 'new_application' | 'new_message' | 'application_accepted' | 'service_completed';
  message: string;
  serviceId?: number;
  timestamp?: string;
  serviceData?: any; // Para carregar informa√ß√µes do servi√ßo quando necess√°rio
};

// Fun√ß√£o para tocar som de notifica√ß√£o
const playNotificationSound = (type: 'message' | 'application' | 'default' = 'default') => {
  try {
    // Podemos usar o mesmo som para todos os tipos por enquanto, mas a fun√ß√£o est√° preparada para sons diferentes
    const audio = new Audio('/notification.mp3');
    
    // Ajustar volume baseado no tipo de notifica√ß√£o
    switch (type) {
      case 'message':
        audio.volume = 0.7; // Volume mais alto para mensagens
        break;
      case 'application':
        audio.volume = 0.6; // Volume m√©dio para candidaturas
        break;
      default:
        audio.volume = 0.5; // Volume padr√£o para outras notifica√ß√µes
    }
    
    audio.play().catch(error => {
      // Alguns navegadores bloqueiam a reprodu√ß√£o autom√°tica
      console.log('Erro ao reproduzir som:', error);
    });
  } catch (error) {
    console.error('Erro ao criar objeto de √°udio:', error);
  }
};

// Fun√ß√£o para enviar notifica√ß√£o do navegador
const sendBrowserNotification = (title: string, body: string, icon: string = '/logo.png') => {
  // Verificar se o navegador suporta notifica√ß√µes
  if (!("Notification" in window)) {
    console.log("Este navegador n√£o suporta notifica√ß√µes desktop");
    return;
  }
  
  // Verificar a permiss√£o
  if (Notification.permission === "granted") {
    // Se for permitido, criar notifica√ß√£o
    new Notification(title, { body, icon });
  } else if (Notification.permission !== "denied") {
    // Caso contr√°rio, pedir permiss√£o
    Notification.requestPermission().then(permission => {
      if (permission === "granted") {
        new Notification(title, { body, icon });
      }
    });
  }
};

export function useWebSocket() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [connected, setConnected] = useState(false);
  const socketRef = useRef<WebSocket | null>(null);
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);

  // Fun√ß√£o para conectar ao WebSocket
  const connect = useCallback(() => {
    if (!user) {
      debugLogger('WebSocket', 'Tentativa de conex√£o sem usu√°rio autenticado');
      return;
    }

    // Fechar conex√£o anterior se existir
    if (socketRef.current) {
      debugLogger('WebSocket', 'Fechando conex√£o WebSocket existente');
      socketRef.current.close();
    }

    // Criar nova conex√£o
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws?userId=${user.id}`;
    
    debugLogger('WebSocket', `Iniciando conex√£o para usu√°rio ${user.id}`, { url: wsUrl });
    
    const socket = new WebSocket(wsUrl);
    socketRef.current = socket;

    socket.onopen = () => {
      debugLogger('WebSocket', 'Conex√£o estabelecida com sucesso');
      setConnected(true);
    };

    socket.onclose = (event) => {
      debugLogger('WebSocket', `Conex√£o fechada: C√≥digo ${event.code}, Motivo: ${event.reason || 'N√£o especificado'}`);
      setConnected(false);
      
      // Tentar reconectar ap√≥s 5 segundos apenas se o componente ainda estiver montado
      if (user) {
        debugLogger('WebSocket', 'Agendando reconex√£o em 5 segundos');
        const timeoutId = setTimeout(() => {
          debugLogger('WebSocket', 'Tentando reconex√£o autom√°tica');
          connect();
        }, 5000);
        
        // Armazenar o ID do timeout para cancelar se necess√°rio
        return () => clearTimeout(timeoutId);
      }
    };

    socket.onerror = (error) => {
      debugLogger('WebSocket', 'Erro na conex√£o WebSocket', error);
      setConnected(false);
    };

    socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data) as WebSocketMessage;
        debugLogger('WebSocket', `Mensagem recebida: ${data.type}`, data);
        
        // Atualizar √∫ltimo estado da mensagem e enviar evento de notifica√ß√£o
        setLastMessage(data);
        
        // Disparar evento global para qualquer componente que precise reagir a novas mensagens
        // (incluindo o indicador de notifica√ß√£o no Bell)
        const notificationEvent = new CustomEvent('new-notification', { 
          detail: { type: data.type, data } 
        });
        window.dispatchEvent(notificationEvent);
        
        // Mostrar notifica√ß√£o toast e invalidar queries necess√°rias
        if (data.type === 'new_application') {
          debugLogger('WebSocket', 'Processando notifica√ß√£o de nova candidatura', {
            serviceId: data.serviceId
          });
          
          // Tocar som de notifica√ß√£o com tipo espec√≠fico
          playNotificationSound('application');
          
          // Enviar notifica√ß√£o do navegador
          sendBrowserNotification(
            'üîî Nova candidatura', 
            data.message || 'Um montador se candidatou ao seu servi√ßo'
          );
          
          // Invalidar consultas para atualizar listas de servi√ßos
          queryClient.invalidateQueries({ queryKey: ['/api/services'] });
          queryClient.invalidateQueries({ queryKey: ['/api/store/services/with-applications'] });
          
          // Mostrar notifica√ß√£o em estilo destacado com anima√ß√£o de pulso
          toast({
            title: 'üîî Nova candidatura',
            description: data.message,
            duration: 8000,
            variant: 'default',
            className: 'bg-blue-100 border-blue-500 border-2 animate-pulse-once shadow-lg'
          });
          
          // Importante: debugar para verificar se isto est√° sendo executado
          debugLogger('WebSocket', 'Notifica√ß√£o de candidatura processada com sucesso', {
            message: data.message,
            serviceId: data.serviceId
          });
        } else if (data.type === 'new_message') {
          debugLogger('WebSocket', 'Processando notifica√ß√£o de nova mensagem', {
            serviceId: data.serviceId
          });
          
          // Tocar som de notifica√ß√£o com tipo espec√≠fico
          playNotificationSound('message');
          
          // Enviar notifica√ß√£o do navegador
          sendBrowserNotification(
            'üí¨ Nova mensagem recebida!', 
            data.message || 'Voc√™ recebeu uma nova mensagem. Clique para visualizar.'
          );
          
          // Invalidar consultas para atualizar mensagens
          if (data.serviceId) {
            queryClient.invalidateQueries({ queryKey: [`/api/services/${data.serviceId}/messages`] });
            queryClient.invalidateQueries({ queryKey: ['/api/services'] });
            queryClient.invalidateQueries({ queryKey: ['/api/services/active'] });
          }
          
          // Mostrar notifica√ß√£o vis√≠vel e com √≠cone e anima√ß√£o
          toast({
            title: 'üí¨ Nova mensagem recebida!',
            description: data.message,
            duration: 8000,
            variant: 'default',
            className: 'bg-green-100 border-green-500 border-2 font-medium shadow-lg animate-pulse-once'
          });
          
          // Vibrar no celular se API estiver dispon√≠vel
          if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200]);
          }
          
          debugLogger('WebSocket', 'Notifica√ß√£o de nova mensagem processada com sucesso', {
            message: data.message,
            serviceId: data.serviceId
          });
        } else if (data.type === 'application_accepted') {
          debugLogger('WebSocket', 'Processando notifica√ß√£o de candidatura aceita', {
            serviceId: data.serviceId
          });
          
          // Tocar som de notifica√ß√£o
          playNotificationSound('application');
          
          // Enviar notifica√ß√£o do navegador
          sendBrowserNotification(
            '‚úÖ Candidatura aceita!', 
            data.message || 'Uma loja aceitou sua candidatura para um servi√ßo'
          );
          
          // Invalidar consultas para atualizar listas de servi√ßos
          queryClient.invalidateQueries({ queryKey: ['/api/services'] });
          
          // Mostrar notifica√ß√£o com estilo personalizado
          toast({
            title: '‚úÖ Candidatura aceita!',
            description: data.message,
            duration: 8000,
            variant: 'default',
            className: 'bg-green-100 border-green-500 border-2 font-medium shadow-lg animate-pulse-once'
          });
          
          // Vibrar no celular se API estiver dispon√≠vel
          if ('vibrate' in navigator) {
            navigator.vibrate([100, 50, 100, 50, 100]);
          }
          
          debugLogger('WebSocket', 'Notifica√ß√£o de candidatura aceita processada com sucesso', {
            message: data.message,
            serviceId: data.serviceId
          });
        } else if (data.type === 'service_completed') {
          debugLogger('WebSocket', 'Processando notifica√ß√£o de servi√ßo finalizado', {
            serviceId: data.serviceId,
            serviceData: data.serviceData
          });
          
          // Tocar som de notifica√ß√£o
          playNotificationSound();
          
          // Enviar notifica√ß√£o do navegador
          sendBrowserNotification(
            'üåü Servi√ßo finalizado!', 
            'Por favor, avalie sua experi√™ncia com este servi√ßo.'
          );
          
          // Invalidar consultas para atualizar listas de servi√ßos
          queryClient.invalidateQueries({ queryKey: ['/api/services'] });
          
          // Disparar evento para abrir tela de avalia√ß√£o
          if (data.serviceId && data.serviceData) {
            // Criar e disparar evento personalizado para abertura do di√°logo de avalia√ß√£o
            const ratingEvent = new CustomEvent('open-rating-dialog', { 
              detail: { 
                serviceId: data.serviceId,
                serviceData: data.serviceData
              } 
            });
            window.dispatchEvent(ratingEvent);
          }
          
          // Mostrar notifica√ß√£o com estilo personalizado
          toast({
            title: 'üåü Servi√ßo finalizado!',
            description: 'Por favor, avalie sua experi√™ncia.',
            duration: 10000,
            variant: 'default',
            className: 'bg-yellow-100 border-yellow-500 border-2 font-medium shadow-lg animate-pulse-once'
          });
          
          debugLogger('WebSocket', 'Notifica√ß√£o de servi√ßo finalizado processada com sucesso', {
            message: data.message,
            serviceId: data.serviceId
          });
        }
      } catch (error) {
        debugLogger('WebSocket', 'Erro ao processar mensagem', error);
      }
    };
  }, [user, toast]);

  // Conectar ao WebSocket quando o usu√°rio estiver dispon√≠vel
  useEffect(() => {
    if (user) {
      connect();
    }
    
    // Limpar ao desmontar
    return () => {
      if (socketRef.current) {
        socketRef.current.close();
      }
    };
  }, [user, connect]);

  return {
    connected,
    lastMessage
  };
}